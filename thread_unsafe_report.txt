LumaEngine 并发安全性静态审计报告
范围：排除第三方库与构建输出（External/**、cmake-build-*/**、Build/**；第三方单文件如 Utils/stb_image.h、Utils/implot.h 不在本报告内）

【高优先级/需修复】
- Application/Editor/ToolBarPanel.h:85,86,88-91,95,96
  Application/Editor/ToolBarPanel.cpp:130,133,170,173,208-221,999-1145
  问题：UI 线程与 std::async 后台线程共享状态未做同步（多处 bool、string、path、float 字段跨线程读写），存在数据竞争与未定义行为。
  说明：如 m_isCompilingScripts, m_compilationFinished, m_compilationSuccess, m_compilationStatus, m_isPackaging, m_packagingStatus,
        m_packagingProgress, m_packagingSuccess, m_lastBuildDirectory 等字段在后台任务中写入、UI 绘制中读取，均未使用互斥锁/原子/消息队列。
  建议：
  - 将完成标志与进度数值改为原子类型（std::atomic<bool>/float）并配合内存序；
  - 跨线程传递 string/path 时使用互斥保护或主线程拷贝；
  - 或使用线程安全队列在 UI 线程应用状态变更。

- Event/EventBus.h:69-71, 79-83, 87-106, 112-126, 131-144
  问题：全局事件总线未加锁；订阅/取消/发布对 m_events、m_unsubscribers、m_nextHandleId 的并发访问存在数据竞争。
  建议：对增删查改加互斥；或限定仅主线程使用。

- Event/LumaEvent.h:89-97, 102-107, 112-118, 130-133, 138
  问题：通用事件容器未加锁；AddListener/RemoveListener/Invoke/Clear 对 m_listeners 并发访问不安全。
  建议：按使用场景加锁或限主线程调用。

- Utils/Logger.h:70,77-79,87-89,225-239,296
  问题：日志回调基于 LumaEvent；跨线程 log 时可能与 Add/Remove 竞争，Invoke 自身也非线程安全。
  建议：统一在主线程分发或为回调容器加锁。

- AIServices/include/ChatBot.h:119-120, 190-203（以及各实现中多处对 Response[...] 的写入）
  AIServices/src/Impls/ChatGPT_Impl.cpp:229-335, 426-546 等
  AIServices/src/Impls/Claude_Impl.cpp:229-371, 395-546 等
  AIServices/src/Impls/CustomRule_Impl.cpp:603-617, 703-811 等
  问题：Response（unordered_map<size_t, tuple<string,bool>>）跨线程读写未加锁（SubmitAsync 新线程写，UI/外部读），多处直接修改/拼接字符串亦非原子。
  建议：为 Response 加互斥；或采用消息通道/生产者-消费者模型；字符串拼接在后台线程完成后一次性交由 UI 线程拷贝。

【中优先级/建议加注释或局部防护】
- Application/RenderableManager.cpp: 2007-2016, 2090-2130 附近（GetInterpolationData）
  问题：进入函数时用 isUpdatingFrames 作为旋锁，但在抓取 View 后即释放，之后的大量构建过程（包括基于 activeBufferIndex 的双缓冲写入、
        对 packetBuffers/transformArenas/textArenas/spriteGroupIndices/textGroupIndices/spriteBatchGroups/textBatchGroups 的写入）未受互斥保护。
  风险：如果多个线程同时调用 GetInterpolationData，可能计算出相同 buildIndex 并并发写同一缓冲与容器，引发数据竞争。
  假设：当前设计可能约定仅渲染线程调用（单线程），若如此请在接口/注释中注明“非线程安全，仅渲染线程调用”；否则应添加重入防护或扩大临界区。

- Application/ImGuiRenderer.cpp:173-210（GetOrCreateTextureIdFor），以及 NewFrame 中对 m_textureCache/m_activeTexturesInFrame 的读写
  问题：ImGui 及缓存容器未加锁，不支持跨线程调用；
  建议：限定仅主线程使用，并在接口/注释中显式声明；如需跨线程准备资源，请采用主线程提交命令方式合入。

- Scripting/MonoHost.cpp: 读：247,269,289,322,344,367,391,413,437,459,483,505；写：838-849
  问题：全局 s_methodContextCache 未加锁；若在初始化或热重载过程中仍可能有调用线程访问，存在数据竞争。
  建议：初始化阶段持锁写入并在切换阶段暂停调用；或将缓存改为只读快照并以原子指针替换。

- Luma_CAPI.cpp: 600-605（注册），585（读取）
  问题：s_freeGCHandleCallback 函数指针读写未同步；若注册与 Job 完成回调并发发生，存在数据竞争。
  建议：注册时持锁或用 std::atomic<ManagedJobCallback>；或在初始化阶段注册一次且不再更改。

【低优先级/主线程假设（建议标注约束）】
- Application/Window.cpp: 161-162（handleEvent 内 static s_dropInProgress/s_dropBatchPaths）
  说明：事件循环通常仅主线程调用；如未来引入多线程事件源，需加锁或改为局部状态。

- Utils/InspectorUI.h:126-128（s_assetPicker* 静态状态）
  说明：仅在 ImGui UI 线程使用安全；跨线程访问需保护。

- PopupManager.h、Components/ComponentRegistry.h、Data/BlueprintNodeRegistry.h、Data/AssetImporterRegistry.h 等
  问题：单例内部维护 map/vector，无锁；通常仅在主线程（编辑器/UI）使用。
  建议：补充“仅主线程使用”的注释；或按需加锁。

【说明】
- 本报告仅覆盖仓库内非第三方/非构建目录代码；未对第三方头（如 Utils/stb_image.h、Utils/implot.h）做审计。
- 判定规则：显式并发原语正确使用的模块（JobSystem、TaskSystem、Camera/SceneManager 的 shared_mutex 等）未归为问题项；
  对于“依赖单线程语义”的模块，若未标注线程约束，按潜在风险列出。
- 建议优先修复：ToolBarPanel 的跨线程 UI 状态读写、事件系统（EventBus/LumaEvent/Logger）的并发安全性、AIServices 的 Response 竞态。
