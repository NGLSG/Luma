using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Luma.SDK.Generator
{
    [Generator]
    public class LogicComponentPropertyGenerator : IIncrementalGenerator
    {
        private const string AttributeFullName = "Luma.SDK.Generation.GenerateLogicComponentPropertiesAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    AttributeFullName,
                    predicate: (node, _) => node is ClassDeclarationSyntax c && c.Modifiers.Any(SyntaxKind.PartialKeyword),
                    transform: (ctx, _) => (ClassDeclarationSyntax)ctx.TargetNode
                );
            
            IncrementalValuesProvider<(ClassDeclarationSyntax ClassSyntax, Compilation Compilation)> classesWithCompilation =
                classDeclarations.Combine(context.CompilationProvider);

            IncrementalValuesProvider<ClassToGenerateInfo?> classInfoToGenerate = classesWithCompilation
                .Select((data, cancellationToken) =>
                {
                    var (classSyntax, compilation) = data;
                    
                    var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);
                    var classSymbol = semanticModel.GetDeclaredSymbol(classSyntax, cancellationToken);

                    if (classSymbol == null) return null;

                    var baseType = classSymbol.BaseType;
                    if (baseType == null || !baseType.IsGenericType || baseType.OriginalDefinition.Name != "LogicComponent")
                    {
                        return null;
                    }
                    
                    var componentStructType = baseType.TypeArguments.FirstOrDefault();
                    if (componentStructType == null) return null;
                    
                    var propertiesToGenerate = classSymbol.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(p => p.DeclaringSyntaxReferences.Any(sr => 
                            sr.GetSyntax(cancellationToken) is PropertyDeclarationSyntax pds && 
                            pds.Modifiers.Any(SyntaxKind.PartialKeyword)))
                        .Select(p => new PropertyToGenerateInfo(p.Name, p.Type.ToDisplayString()))
                        .ToImmutableArray();
                    
                    if (propertiesToGenerate.IsEmpty) return null;

                    return new ClassToGenerateInfo(
                        classSymbol.Name,
                        classSymbol.ContainingNamespace.ToDisplayString(),
                        componentStructType.GetMembers(),
                        propertiesToGenerate
                    );
                });
                
            context.RegisterSourceOutput(classInfoToGenerate.Where(info => info != null), (spc, classInfo) =>
            {
                string sourceCode = GenerateSourceCode(classInfo!);
                spc.AddSource($"{classInfo!.Name}.g.cs", sourceCode);
            });
        }
        
        private string GenerateSourceCode(ClassToGenerateInfo classInfo)
        {
            var codeBuilder = new StringBuilder();
            codeBuilder.AppendLine("// <auto-generated/>");
            codeBuilder.AppendLine("#nullable enable");
            codeBuilder.AppendLine();
            codeBuilder.AppendLine($"namespace {classInfo.Namespace};");
            codeBuilder.AppendLine();
            codeBuilder.AppendLine($"public partial class {classInfo.Name}");
            codeBuilder.AppendLine("{");

            
            var structFields = classInfo.ComponentStructMembers.OfType<IFieldSymbol>().ToImmutableArray();

            foreach (var prop in classInfo.Properties)
            {
                
                var matchedField = structFields.FirstOrDefault(f => 
                    f.Name.Equals(prop.Name, StringComparison.OrdinalIgnoreCase));
                
                if (matchedField != null)
                {
                    
                    string fieldName = matchedField.Name; 

                    codeBuilder.AppendLine($"    public partial {prop.Type} {prop.Name}");
                    codeBuilder.AppendLine("    {");
                    codeBuilder.AppendLine($"        get => Component.{fieldName};");
                    codeBuilder.AppendLine("        set => UpdateComponent(data => {");
                    codeBuilder.AppendLine($"            data.{fieldName} = value;");
                    codeBuilder.AppendLine("            return data;");
                    codeBuilder.AppendLine("        });");
                    codeBuilder.AppendLine("    }");
                }
            }

            codeBuilder.AppendLine("}");
            return codeBuilder.ToString();
        }
        
        private record ClassToGenerateInfo(
            string Name,
            string Namespace,
            ImmutableArray<ISymbol> ComponentStructMembers,
            ImmutableArray<PropertyToGenerateInfo> Properties
        );

        private record PropertyToGenerateInfo(string Name, string Type);
    }
    
}